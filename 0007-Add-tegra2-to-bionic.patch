From 1b8af0167026113ad1184c5081f9eaa3181d29b6 Mon Sep 17 00:00:00 2001
From: Nikhil <nikhil@menghani.com>
Date: Tue, 29 Jul 2014 20:27:19 +0530
Subject: [PATCH] Add tegra2 to bionic

---
 libc/Android.mk                      |  90 +++++++++++----------
 libc/arch-arm/terga2/bionic/memchr.S | 151 +++++++++++++++++++++++++++++++++++
 libc/arch-arm/terga2/bionic/strlen.S | 111 +++++++++++++++++++++++++
 libc/arch-arm/terga2/tegra2.mk       |  13 +++
 4 files changed, 323 insertions(+), 42 deletions(-)
 create mode 100644 libc/arch-arm/terga2/bionic/memchr.S
 create mode 100644 libc/arch-arm/terga2/bionic/strlen.S
 create mode 100644 libc/arch-arm/terga2/tegra2.mk

diff --git a/libc/Android.mk b/libc/Android.mk
index 5957ea7..7bb5906 100755
--- a/libc/Android.mk
+++ b/libc/Android.mk
@@ -182,8 +182,15 @@ libc_common_src_files := \
 	netbsd/nameser/ns_print.c \
 	netbsd/nameser/ns_samedomain.c \
 
+# cortex-a9 without neon
+ifneq ($(TARGET_CPU_VARIANT),tegra2)
+    libc_common_src_files = \
+        bionic/memchr.c \
+
+endif
+
 # Fortify implementations of libc functions.
-libc_common_src_files += \
+libc_common_src_files = \
     bionic/__fgets_chk.cpp \
     bionic/__memcpy_chk.cpp \
     bionic/__memmove_chk.cpp \
@@ -366,11 +373,10 @@ libc_upstream_netbsd_src_files := \
 # Architecture specific source files go here
 # =========================================================
 ifeq ($(TARGET_ARCH),arm)
-libc_common_src_files += \
+libc_common_src_files = \
 	string/strncpy.c \
 	bionic/strchr.cpp \
 	string/strrchr.c \
-	bionic/memchr.c \
 	bionic/memrchr.c \
 	string/index.c \
 	string/strlcpy.c \
@@ -385,13 +391,13 @@ libc_common_src_files += \
 # These files need to be arm so that gdbserver
 # can set breakpoints in them without messing
 # up any thumb code.
-libc_common_src_files += \
+libc_common_src_files = \
 	bionic/pthread-atfork.c.arm \
 	bionic/pthread-rwlocks.c.arm \
 	bionic/pthread-timers.c.arm \
 	bionic/ptrace.c.arm
 
-libc_static_common_src_files += \
+libc_static_common_src_files = \
     bionic/pthread.c.arm \
     bionic/pthread_create.cpp.arm \
     bionic/pthread_key.cpp.arm \
@@ -399,23 +405,23 @@ libc_static_common_src_files += \
 endif # arm
 
 ifeq ($(TARGET_ARCH),x86)
-libc_common_src_files += \
+libc_common_src_files = \
     bionic/pthread-atfork.c \
     bionic/pthread-rwlocks.c \
     bionic/pthread-timers.c \
     bionic/ptrace.c \
 
-libc_static_common_src_files += \
+libc_static_common_src_files = \
     bionic/pthread.c \
     bionic/pthread_create.cpp \
     bionic/pthread_key.cpp \
 
-libc_common_src_files += \
+libc_common_src_files = \
     bionic/memchr.c
 endif # x86
 
 ifeq ($(TARGET_ARCH),mips)
-libc_common_src_files += \
+libc_common_src_files = \
 	bionic/memcmp.c \
 	string/bcopy.c \
 	string/strcmp.c \
@@ -440,13 +446,13 @@ libc_common_src_files += \
 	upstream-freebsd/lib/libc/string/wcslen.c \
 	upstream-freebsd/lib/libc/string/wcscat.c
 
-libc_common_src_files += \
+libc_common_src_files = \
 	bionic/pthread-atfork.c \
 	bionic/pthread-rwlocks.c \
 	bionic/pthread-timers.c \
 	bionic/ptrace.c
 
-libc_static_common_src_files += \
+libc_static_common_src_files = \
     bionic/pthread.c \
     bionic/pthread_create.cpp \
     bionic/pthread_key.cpp \
@@ -472,7 +478,7 @@ $(if $(filter true,$(_LIBC_ARCH_CPU_VARIANT_HAS_$(1))), \
 	, \
      $(eval _LIBC_ARCH_CPU_VARIANT_HAS_$(1) := true) \
      $(eval _LIBC_ARCH_CPU_VARIANT_SRC_FILE.$(1) := $(2)) \
-     $(eval _LIBC_ARCH_CPU_VARIANT_SRC_FILES += $(2)) \
+     $(eval _LIBC_ARCH_CPU_VARIANT_SRC_FILES = $(2)) \
 )
 endef
 
@@ -482,8 +488,8 @@ _LIBC_ARCH_STATIC_SRC_FILES :=
 _LIBC_ARCH_DYNAMIC_SRC_FILES :=
 include bionic/libc/arch-$(TARGET_ARCH)/$(TARGET_ARCH).mk
 
-libc_common_src_files += $(_LIBC_ARCH_COMMON_SRC_FILES)
-libc_common_src_files += $(_LIBC_ARCH_CPU_VARIANT_SRC_FILES)
+libc_common_src_files = $(_LIBC_ARCH_COMMON_SRC_FILES)
+libc_common_src_files = $(_LIBC_ARCH_CPU_VARIANT_SRC_FILES)
 libc_arch_static_src_files := $(_LIBC_ARCH_STATIC_SRC_FILES)
 libc_arch_dynamic_src_files := $(_LIBC_ARCH_DYNAMIC_SRC_FILES)
 
@@ -501,54 +507,54 @@ libc_common_cflags := \
     -Wall -Wextra
 
 ifeq ($(strip $(DEBUG_BIONIC_LIBC)),true)
-  libc_common_cflags += -DDEBUG
+  libc_common_cflags = -DDEBUG
 endif
 
 # To customize dlmalloc's alignment, set BOARD_MALLOC_ALIGNMENT in
 # the appropriate BoardConfig.mk file.
 #
 ifneq ($(BOARD_MALLOC_ALIGNMENT),)
-  libc_common_cflags += -DMALLOC_ALIGNMENT=$(BOARD_MALLOC_ALIGNMENT)
+  libc_common_cflags = -DMALLOC_ALIGNMENT=$(BOARD_MALLOC_ALIGNMENT)
 endif
 
 ifeq ($(TARGET_ARCH),arm)
-  libc_common_cflags += -DSOFTFLOAT
-  libc_common_cflags += -fstrict-aliasing
+  libc_common_cflags = -DSOFTFLOAT
+  libc_common_cflags = -fstrict-aliasing
   libc_crt_target_cflags := -mthumb-interwork
 endif # !arm
 
 ifeq ($(TARGET_ARCH),x86)
-  libc_common_cflags += -DSOFTFLOAT
+  libc_common_cflags = -DSOFTFLOAT
   libc_crt_target_cflags :=
   ifeq ($(ARCH_X86_HAVE_SSE2),true)
-      libc_crt_target_cflags += -DUSE_SSE2=1
+      libc_crt_target_cflags = -DUSE_SSE2=1
   endif
   ifeq ($(ARCH_X86_HAVE_SSSE3),true)
-      libc_crt_target_cflags += -DUSE_SSSE3=1
+      libc_crt_target_cflags = -DUSE_SSSE3=1
   endif
 endif # x86
 
 ifeq ($(ARCH_ARM_HAVE_ARMV7A),true)
-  libc_common_cflags += -DNEON_UNALIGNED_ACCESS -DNEON_MEMCPY_ALIGNMENT_DIVIDER=224
+  libc_common_cflags = -DNEON_UNALIGNED_ACCESS -DNEON_MEMCPY_ALIGNMENT_DIVIDER=224
 endif
 
 ifeq ($(TARGET_ARCH),mips)
   ifneq ($(ARCH_MIPS_HAS_FPU),true)
-    libc_common_cflags += -DSOFTFLOAT
+    libc_common_cflags = -DSOFTFLOAT
   endif
-  libc_common_cflags += -fstrict-aliasing
+  libc_common_cflags = -fstrict-aliasing
   libc_crt_target_cflags := $(TARGET_GLOBAL_CFLAGS)
 endif # mips
 
 # Define ANDROID_SMP appropriately.
 ifeq ($(TARGET_CPU_SMP),true)
-    libc_common_cflags += -DANDROID_SMP=1
+    libc_common_cflags = -DANDROID_SMP=1
 else
-    libc_common_cflags += -DANDROID_SMP=0
+    libc_common_cflags = -DANDROID_SMP=0
 endif
 
 # crtbrand.c needs <stdint.h> and a #define for the platform SDK version.
-libc_crt_target_cflags += \
+libc_crt_target_cflags = \
     -I$(LOCAL_PATH)/include  \
     -DPLATFORM_SDK_VERSION=$(PLATFORM_SDK_VERSION)
 
@@ -562,7 +568,7 @@ libc_common_c_includes := \
 
 # Needed to access private/__dso_handle.h from
 # crtbegin_xxx.S and crtend_xxx.S
-libc_crt_target_cflags += \
+libc_crt_target_cflags = \
     -I$(LOCAL_PATH)/private \
     -I$(LOCAL_PATH)/arch-$(TARGET_ARCH)/include
 
@@ -578,7 +584,7 @@ libc_crt_target_cflags += \
 #
 # For all the platforms, the .fini_array section must point to a function
 # that will call __cxa_finalize(&__dso_handle) in order to ensure that
-# static C++ destructors are properly called on dlclose().
+# static C destructors are properly called on dlclose().
 #
 ifeq ($(TARGET_ARCH),arm)
     libc_crt_target_so_cflags :=
@@ -589,7 +595,7 @@ endif
 ifeq ($(TARGET_ARCH),x86)
     libc_crt_target_so_cflags := -fPIC
 endif
-libc_crt_target_so_cflags += $(libc_crt_target_cflags)
+libc_crt_target_so_cflags = $(libc_crt_target_cflags)
 libc_crt_target_crtbegin_file := $(LOCAL_PATH)/arch-$(TARGET_ARCH)/bionic/crtbegin.c
 libc_crt_target_crtbegin_so_file := $(LOCAL_PATH)/arch-$(TARGET_ARCH)/bionic/crtbegin_so.c
 
@@ -603,13 +609,13 @@ $(GEN): $(LOCAL_PATH)/bionic/crtbrand.c
 	$(hide) sed -i -e '/\.note\.ABI-tag/s/progbits/note/' $@
 	$(call transform-d-to-p-args,$(@:%.s=%.d),$(@:%.s=%.P))
 -include $(GEN:%.s=%.P)
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 GEN := $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbrand.o
 $(GEN): $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbrand.s
 	@mkdir -p $(dir $@)
 	$(hide) $(TARGET_CC) $(libc_crt_target_so_cflags) -o $@ -c $<
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 GEN := $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbegin_so.o
 $(GEN): $(libc_crt_target_crtbegin_so_file)
@@ -618,7 +624,7 @@ $(GEN): $(libc_crt_target_crtbegin_so_file)
 		-MD -MF $(@:%.o=%.d) -o $@ -c $<
 	$(transform-d-to-p)
 -include $(GEN:%.o=%.P)
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 GEN := $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtend_so.o
 $(GEN): $(LOCAL_PATH)/arch-$(TARGET_ARCH)/bionic/crtend_so.S
@@ -627,18 +633,18 @@ $(GEN): $(LOCAL_PATH)/arch-$(TARGET_ARCH)/bionic/crtend_so.S
 		-MD -MF $(@:%.o=%.d) -o $@ -c $<
 	$(transform-d-to-p)
 -include $(GEN:%.o=%.P)
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 # The following two are installed to device
 GEN := $(TARGET_OUT_SHARED_LIBRARIES)/crtbegin_so.o
 $(GEN): $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbegin_so.o
 	$(hide) mkdir -p $(dir $@) && cp -f $< $@
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 GEN := $(TARGET_OUT_SHARED_LIBRARIES)/crtend_so.o
 $(GEN): $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtend_so.o
 	$(hide) mkdir -p $(dir $@) && cp -f $< $@
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 
 GEN := $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbegin_static1.o
@@ -648,13 +654,13 @@ $(GEN): $(libc_crt_target_crtbegin_file)
 		-MD -MF $(@:%.o=%.d) -o $@ -c $<
 	$(transform-d-to-p)
 -include $(GEN:%.o=%.P)
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 GEN := $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbegin_static.o
 $(GEN): $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbegin_static1.o $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbrand.o
 	@mkdir -p $(dir $@)
 	$(hide) $(TARGET_LD) -r -o $@ $^
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 GEN := $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbegin_dynamic1.o
 $(GEN): $(libc_crt_target_crtbegin_file)
@@ -663,13 +669,13 @@ $(GEN): $(libc_crt_target_crtbegin_file)
 		-MD -MF $(@:%.o=%.d) -o $@ -c $<
 	$(transform-d-to-p)
 -include $(GEN:%.o=%.P)
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 GEN := $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbegin_dynamic.o
 $(GEN): $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbegin_dynamic1.o $(TARGET_OUT_INTERMEDIATE_LIBRARIES)/crtbrand.o
 	@mkdir -p $(dir $@)
 	$(hide) $(TARGET_LD) -r -o $@ $^
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 # We rename crtend.o to crtend_android.o to avoid a
 # name clash between gcc and bionic.
@@ -680,7 +686,7 @@ $(GEN): $(LOCAL_PATH)/arch-$(TARGET_ARCH)/bionic/crtend.S
 		-MD -MF $(@:%.o=%.d) -o $@ -c $<
 	$(transform-d-to-p)
 -include $(GEN:%.o=%.P)
-ALL_GENERATED_SOURCES += $(GEN)
+ALL_GENERATED_SOURCES = $(GEN)
 
 
 # To enable malloc leak check for statically linked programs, add
@@ -896,7 +902,7 @@ LOCAL_SRC_FILES := \
 
 ifeq ($(TARGET_ARCH),arm)
 	LOCAL_NO_CRT := true
-	LOCAL_CFLAGS += -DCRT_LEGACY_WORKAROUND
+	LOCAL_CFLAGS = -DCRT_LEGACY_WORKAROUND
 
 	LOCAL_SRC_FILES := \
 		arch-arm/bionic/crtbegin_so.c \
diff --git a/libc/arch-arm/terga2/bionic/memchr.S b/libc/arch-arm/terga2/bionic/memchr.S
new file mode 100644
index 0000000..de8a57c
--- /dev/null
+++ b/libc/arch-arm/terga2/bionic/memchr.S
@@ -0,0 +1,151 @@
+/* Copyright (c) 2010-2011, Linaro Limited
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+      * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+      * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+      * Neither the name of Linaro Limited nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+   Written by Dave Gilbert <david.gilbert@linaro.org>
+
+   This memchr routine is optimised on a Cortex-A9 and should work on
+   all ARMv7 processors.   It has a fast past for short sizes, and has
+   an optimised path for large data sets; the worst case is finding the
+   match early in a large data set. */
+
+@ 2011-02-07 david.gilbert@linaro.org
+@    Extracted from local git a5b438d861
+@ 2011-07-14 david.gilbert@linaro.org
+@    Import endianness fix from local git ea786f1b
+@ 2011-12-07 david.gilbert@linaro.org
+@    Removed unneeded cbz from align loop
+
+	.syntax unified
+	.arch armv7-a
+
+@ this lets us check a flag in a 00/ff byte easily in either endianness
+#ifdef __ARMEB__
+#define CHARTSTMASK(c) 1<<(31-(c*8))
+#else
+#define CHARTSTMASK(c) 1<<(c*8)
+#endif
+	.text
+	.thumb
+
+@ ---------------------------------------------------------------------------
+	.thumb_func
+	.align 2
+	.p2align 4,,15
+	.global memchr
+	.type memchr,%function
+memchr:
+	@ r0 = start of memory to scan
+	@ r1 = character to look for
+	@ r2 = length
+	@ returns r0 = pointer to character or NULL if not found
+	and	r1,r1,#0xff	@ Don't think we can trust the caller to actually pass a char
+
+	cmp	r2,#16		@ If it's short don't bother with anything clever
+	blt	20f
+
+	tst	r0, #7		@ If it's already aligned skip the next bit
+	beq	10f
+
+	@ Work up to an aligned point
+5:
+	ldrb	r3, [r0],#1
+	subs	r2, r2, #1
+	cmp	r3, r1
+	beq	50f		@ If it matches exit found
+	tst	r0, #7
+	bne	5b		@ If not aligned yet then do next byte
+
+10:
+	@ At this point, we are aligned, we know we have at least 8 bytes to work with
+	push	{r4,r5,r6,r7}
+	orr	r1, r1, r1, lsl #8	@ expand the match word across to all bytes
+	orr	r1, r1, r1, lsl #16
+	bic	r4, r2, #7	@ Number of double words to work with
+	mvns	r7, #0		@ all F's
+	movs	r3, #0
+
+15:
+	ldmia	r0!,{r5,r6}
+	subs	r4, r4, #8
+	eor	r5,r5, r1	@ Get it so that r5,r6 have 00's where the bytes match the target
+	eor	r6,r6, r1
+	uadd8	r5, r5, r7	@ Parallel add 0xff - sets the GE bits for anything that wasn't 0
+	sel	r5, r3, r7	@ bytes are 00 for none-00 bytes, or ff for 00 bytes - NOTE INVERSION
+	uadd8	r6, r6, r7	@ Parallel add 0xff - sets the GE bits for anything that wasn't 0
+	sel	r6, r5, r7	@ chained....bytes are 00 for none-00 bytes, or ff for 00 bytes - NOTE INVERSION
+	cbnz	r6, 60f
+	bne	15b		@ (Flags from the subs above) If not run out of bytes then go around again
+
+	pop	{r4,r5,r6,r7}
+	and	r1,r1,#0xff	@ Get r1 back to a single character from the expansion above
+	and	r2,r2,#7	@ Leave the count remaining as the number after the double words have been done
+
+20:
+	cbz	r2, 40f		@ 0 length or hit the end already then not found
+
+21:  @ Post aligned section, or just a short call
+	ldrb	r3,[r0],#1
+	subs	r2,r2,#1
+	eor	r3,r3,r1	@ r3 = 0 if match - doesn't break flags from sub
+	cbz	r3, 50f
+	bne	21b		@ on r2 flags
+
+40:
+	movs	r0,#0		@ not found
+	bx	lr
+
+50:
+	subs	r0,r0,#1	@ found
+	bx	lr
+
+60:  @ We're here because the fast path found a hit - now we have to track down exactly which word it was
+	@ r0 points to the start of the double word after the one that was tested
+	@ r5 has the 00/ff pattern for the first word, r6 has the chained value
+	cmp	r5, #0
+	itte	eq
+	moveq	r5, r6		@ the end is in the 2nd word
+	subeq	r0,r0,#3	@ Points to 2nd byte of 2nd word
+	subne	r0,r0,#7	@ or 2nd byte of 1st word
+
+	@ r0 currently points to the 3rd byte of the word containing the hit
+	tst	r5, # CHARTSTMASK(0)	@ 1st character
+	bne	61f
+	adds	r0,r0,#1
+	tst	r5, # CHARTSTMASK(1)	@ 2nd character
+	ittt	eq
+	addeq	r0,r0,#1
+	tsteq	r5, # (3<<15)		@ 2nd & 3rd character
+	@ If not the 3rd must be the last one
+	addeq	r0,r0,#1
+
+61:
+	pop	{r4,r5,r6,r7}
+	subs	r0,r0,#1
+	bx	lr
diff --git a/libc/arch-arm/terga2/bionic/strlen.S b/libc/arch-arm/terga2/bionic/strlen.S
new file mode 100644
index 0000000..125e92f
--- /dev/null
+++ b/libc/arch-arm/terga2/bionic/strlen.S
@@ -0,0 +1,111 @@
+/* Copyright (c) 2010-2011, Linaro Limited
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+      * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+      * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+      * Neither the name of Linaro Limited nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+   Written by Dave Gilbert <david.gilbert@linaro.org>
+
+   This strlen routine is optimised on a Cortex-A9 and should work on
+   all ARMv7 processors.   This routine is reasonably fast for short
+   strings, but is probably slower than a simple implementation if all
+   your strings are very short */
+
+@ 2011-02-08 david.gilbert@linaro.org
+@    Extracted from local git 6848613a
+
+
+@ this lets us check a flag in a 00/ff byte easily in either endianness
+#ifdef __ARMEB__
+#define CHARTSTMASK(c) 1<<(31-(c*8))
+#else
+#define CHARTSTMASK(c) 1<<(c*8)
+#endif
+
+@-----------------------------------------------------------------------------------------------------------------------------
+	.syntax unified
+	.arch armv7-a
+
+	.thumb_func
+	.align 2
+	.p2align 4,,15
+	.global strlen
+	.type strlen,%function
+strlen:
+	@ r0 = string
+	@ returns count of bytes in string not including terminator
+	mov	r1, r0
+	push	{ r4,r6 }
+	mvns	r6, #0		@ all F
+	movs	r4, #0
+	tst	r0, #7
+	beq	2f
+
+1:
+	ldrb	r2, [r1], #1
+	tst	r1, #7		@ Hit alignment yet?
+	cbz	r2, 10f		@ Exit if we found the 0
+	bne	1b
+
+	@ So we're now aligned
+2:
+	ldmia	r1!,{r2,r3}
+	uadd8	r2, r2, r6	@ Parallel add 0xff - sets the GE bits for anything that wasn't 0
+	sel	r2, r4, r6	@ bytes are 00 for none-00 bytes, or ff for 00 bytes - NOTE INVERSION
+	uadd8	r3, r3, r6	@ Parallel add 0xff - sets the GE bits for anything that wasn't 0
+	sel	r3, r2, r6	@ bytes are 00 for none-00 bytes, or ff for 00 bytes - NOTE INVERSION
+	cmp	r3, #0
+	beq	2b
+
+strlenendtmp:
+	@ One (or more) of the bytes we loaded was 0 - but which one?
+	@ r2 has the mask corresponding to the first loaded word
+	@ r3 has a combined mask of the two words - but if r2 was all-non 0 
+	@ then it's just the 2nd words
+	cmp	r2, #0
+	itte	eq
+	moveq	r2, r3		@ the end is in the 2nd word
+	subeq	r1,r1,#3
+	subne	r1,r1,#7
+
+	@ r1 currently points to the 2nd byte of the word containing the 0
+	tst	r2, # CHARTSTMASK(0)	@ 1st character
+	bne	10f
+	adds	r1,r1,#1
+	tst	r2, # CHARTSTMASK(1)	@ 2nd character
+	ittt	eq
+	addeq	r1,r1,#1
+	tsteq	r2, # (3<<15)	@ 2nd & 3rd character
+	@ If not the 3rd must be the last one
+	addeq	r1,r1,#1
+
+10:
+	@ r0 is still at the beginning, r1 is pointing 1 byte after the terminator
+	sub	r0, r1, r0
+	subs	r0, r0, #1
+	pop	{ r4, r6 }
+	bx	lr
diff --git a/libc/arch-arm/terga2/tegra2.mk b/libc/arch-arm/terga2/tegra2.mk
new file mode 100644
index 0000000..5c34887
--- /dev/null
+++ b/libc/arch-arm/terga2/tegra2.mk
@@ -0,0 +1,13 @@
+$(call libc-add-cpu-variant-src,MEMCPY,arch-arm/generic/bionic/memcpy.S)
+$(call libc-add-cpu-variant-src,MEMSET,arch-arm/generic/bionic/memset.S)
+$(call libc-add-cpu-variant-src,STRCMP,arch-arm/cortex-a15/bionic/strcmp.S)
+$(call libc-add-cpu-variant-src,STRCPY,arch-arm/generic/bionic/strcpy.S)
+$(call libc-add-cpu-variant-src,__STRCPY_CHK,bionic/__strcpy_chk.cpp)
+$(call libc-add-cpu-variant-src,MEMMOVE,bionic/memmove.c.arm)
+$(call libc-add-cpu-variant-src,BCOPY,string/bcopy.c.arm)
+$(call libc-add-cpu-variant-src,STRCAT,string/strcat.c)
+$(call libc-add-cpu-variant-src,__STRCAT_CHK,bionic/__strcat_chk.cpp)
+
+# armv7-a (non neon) ones from cm10.1
+$(call libc-add-cpu-variant-src,STRLEN,arch-arm/tegra2/bionic/strlen.S)
+$(call libc-add-cpu-variant-src,MEMCHR,arch-arm/tegra2/bionic/memchr.S)
-- 
1.9.1

